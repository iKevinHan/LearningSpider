数据结构综合测试题 


一、单选题 


1.　  以下数据结构中哪一个是线性结构？(　 ) 


　　　　A. 有向图　 　　　B. 栈　　　　C. 线索二叉树　　　　D. B树 


2.　　 在一个单链表HL中，若要向表头插入一个由指针p指向的结点，则执行(　 )。 


A. HL=p; p-&gt;next=HL; 　　　　　B. p-&gt;next=HL; HL=p; 


　　　 C. p-&gt;next=HL; p=HL; 　　　　　D. p-&gt;next=HL-&gt;next; HL-&gt;next=p; 


3.　　 在一个带有头结点的单链表HL中，若要向表头插入一个由指针p指向的结点，则执行(　 )。 


　　A. HL=p; p-&gt;next=HL; 　　　　 B. p-&gt;next=HL; HL=p; 


　　　　　 C. p-&gt;next=HL; p=HL; 　　　　　D. p-&gt;next=HL-&gt;next; HL-&gt;next=p; 


4.　　　 单链表的每个结点中包括一个指针next，它指向该结点的后继结点。现要将指针q指向的新结点插入到指针p指向的单链表结点之后，下面的操作序列中哪一个是正确的？（　 ） 


　 A．q=p-&gt;next; p-&gt;next=q-&gt;next;　　  B.p-&gt;next=q-&gt;next;q=p-&gt;next 


　 C. q-&gt;next=p-&gt;next; p-&gt;next=q;　　　 D. P-&gt;next=q; q-&gt;next=p-&gt;next; 


5.　　　　 在一个循环顺序存储的队列中，队首指针指向队首元素的（　 ）位置。 


　　　　A． 前一个　　　B. 后一个　　　C. 当前　　  


6.　　　 以下哪一个不是队列的基本运算？（　 ） 


　  　　A.从队尾插入一个新元素　　　　  B.从队列中删除第i个元素 


　　　  C.判断一个队列是否为空　　　　  D.读取队头元素的值 


7.　　　 用链接方式存储的队列，在进行删除运算时(　 ). 


　　　　A.仅修改头指针  　　　　　  B.仅修改尾指针 


　　　  C.头、尾指针都要修改　　　  D.头、尾指针可能都要修改 


8.　  对线性表，在下列哪种情况下应当采用链表表示？(　 ) 


　　　  A.经常需要随机地存取元素　　　　　　　  B.经常需要进行插入和删除操作 


　　　  C.表中元素需要占据一片连续的存储空间　  D.表中元素的个数不变 


9.　  字符A、B、C依次进入一个栈，按出栈的先后顺序组成不同的字符串，至多可以组成(　 )个不同的字符串？ 


　　　  A.5　　　　　 B.4　　 　　　  C.6　　　  　　　　 D.1 


10. 下述哪一条是顺序存储方式的优点？（　） 


　  　　A．存储密度大　　　　 　　 B.插入运算方便  


　　　　C. 删除运算方便　　　　  　D.可方便地用于各种逻辑结构的存储表示 


11.　  从二叉搜索树中查找一个元素时，其时间复杂度大致为(　 )。 


　　　　A. O(n)　　　B. O(1)　　　C. O(log2n)　　　D. O(n2) 


12.
　  由权值分别为3,8,6,2,5的叶子结点生成一棵哈夫曼树，它的带权路径长度为________。 


　　
　 A 24　　　B 48　　  C 72 　　 D 53 


13.　  下列关于二叉树遍历的叙述中，正确的是(　 ) 。 


A.若一个结点是某二叉树的中序遍历的最后一个结点，则它必是该二叉树的前序最后一个结点 


B．若一个点是某二叉树的前序遍历最后一个结点，则它必是该二叉树的中序遍历的最后一个结点 


C．若一个树叶是某二叉树的中序遍历的最后一个结点，则它必是该二叉树的前序遍历最后一个结点 


　 　D．若一个树叶是某二叉树的前序最后一个结点，则它必是该二叉树的中序遍历最后一个结点 


14.　　高度k的二叉树的最大结点数为(　). 


A．2k-1　　　 B.2K+1　　　C.2K-1　　　　D. 2k-1　　　  


15.　  下面关于图的存储的叙述中正确的是(　 ). 


　   A．用邻接表法存储图，占用的存储空间大小只与图中结点个数有关，而与边数无关 


　   B．用邻接表法存储图，占用的存储空间大小只与图中边数有关，而与结点个数无关 


C. 用邻接矩阵法存储图，占用的存储空间大小只与图中结点个数有关，而与边数无关 


　 　D．用邻接矩阵法存储图，占用的存储空间大小只与图中边数有关，而与结点个数无关 


16. 在顺序表(2,5,7,10,14,15,18,23,35,41,52)中,用二分法查找关键码值10,所需的关键码比较次数为 


　　　 A.2　　　　 B.3　　　  　C.4　　　　  D.5 


17.　  对线性表进行二分法查找，其前提条件是(　 ). 


A.线性表以顺序方式存储，并且按关键码值排好序　  


B.线性表以顺序方式存储，并且按关键码值的检索频率排好序 


C.线性表以链接方式存储，并且按关键码值排好序 


D.线性表以链接方式存储，并且按关键码值的检索频率排好序 


18.　  下列哪一个关键码序列不符合堆的定义？(　 ) 


A.  a、c、d、g、h、m、p、q、r、x　　　　  B. a、c、m、d、h、p、x、g、o、r 


　　 C.　a、d、p、r、c、q、x、m、h、g 　　　　　D. a、d、c、m、p、g、h、x、r、q 


19.　  对n个记录的文件进行快速排序，所需要的辅助存储空间为 


　 A. O（1）　　  　　B.　O（1og2n）　　　　 C.  O（n）　　　　 D. O（n2） 


20.　  在待排序文件已基本有序的前提下，下述排序方法中效率最高的是 


　 A.直接插入排序　　　B.直接选择排序 　　　C.快速排序 　　　 D.归并排序 


21.　  设有关键码序列(q，g，m，z，a，n，p，x，h)，下面哪一个序列是从上述序列出发建堆的结果? 


　 A.　a，g，h，m，n，p，q，x
，z　 　　　 B.　 a，g，m，h，q，n，p，x，z 


　 C.  g，m，q，a，n，p，x，h，z　　　　  D.　 h，g，m，p，a，n，q，x，z 


22.下列关
于数据结构的叙述中，正确的是(　 ). 


A.　　数组是同类型值的集合  


B.　  递归算法的程序结构比迭代算法的程序结构更为精炼 


C.　　树是一种线性结构 


D.　  用一维数组存储二叉树，总是以先序遍历的顺序存储各结点 


　  二、填空题 


1.　　　 数据的逻辑结构被分为_________、________、__________和___________四种。 


2.　　　 数据的物理结构被分为_________、________、__________和___________四种。 


3.　　　 一个算法的时间复杂度为(3n2+2nlog2 n+4n-7)/(5n)，其数量级表示为________。 


4.　　　 对于一个长度为n的单链存储的线性表，在表头插入元素的时间复杂度为_________，在表尾插入元素的时间复杂度为____________。 


5.　　　 对于一个长度为n的顺序存储的线性表，在表头插入元素的时间复杂度为_________，在表尾插入元素的时间复杂度为____________。 


6.　　　 在以HL为表头指针的带表头附加结点的单链表和循环单链表中，链表为空的条件分别为________和________。 


7.　　　 一个广义表中的元素分为________元素和________元素两类。 


8.　　　 从一个链栈中删除一个结点时，需要把栈顶结点的_________域的值赋给________。 


9.　　　 进行函数调用时，需要把每个实参的值和调用后的________传送给被调用的函数中。 


10.　  设W为一个二维数组，其每个数据元素占用6个字节，行下标i从0到8 ，列下标j从0到3 ，则二维数组W的数据元素共占用＿＿个字节。W中第6 行的元素和第4 列的元素共占用＿＿个字节。若按行顺序存放二维数组W，其起始地址为100，则二维数组W的最后一个数据元素的起始地址为＿＿。 


11.　  在线性表的单链存储中，若一个元素所在的结点地址为p，则其后继结点的地址为_________，若假定p为一个数组a中的下标，则其后继结点的下标为_____________。 


12.　  在稀疏矩阵所对应的三元组线性表中，每个三元组元素按_________为主序、_________为辅序的次序排列。 


13.　  栈又称为_______________表，队列又称为___________表。 


14.　  中缀算式（3+4）*2/（8-5）所对应的后缀算式为_______________________________。 


15.　　后缀算式4 2 3 * + 10 5 / -的值为__________。 


16.　  对于一棵具有n个结点的二叉树，一个结点的编号为i(1≤i≤n)，若它有左孩子则左孩子结点的编号为________，若它有右孩子，则右孩子结点的编号为________，若它有双亲，则双亲结
点的编号为________。 


17.　  在一棵高度为5的理想平衡树中，最少含有________个结点，最多含有________个结点。 


18.　  假定一棵树的广义表表示为A（B（C，D（E，F，G），H
（I，J））），则树中所含的结点数为____个，树的深度为______，树的度为_________。 


19.　  若一棵二叉树中只有叶子结点和左、右子树皆非空的结点，设叶结点的个数为K，则左、右子树皆非空的结点个数是________。 


20.　  在树中，一个结点的直接后继结点的个数称为该结点的________。 


21.　  在n个带权叶子结点构造出的所有二叉树中，带权路径长度最小的二叉树称为________。WPL称为_____________________。 


22.　  对一棵二叉搜索树进行中序遍历时，得到的结点序列是一个__________。 


23.　  当向一个小根堆插入一个具有最小值的元素时，需要逐层_________调整，直到被调整到____________位置为止。 


24.　  在一个堆的顺序存储中，若一个元素的下标为i(0≤i≤n-1)，则它的左孩子元素的下标为______，右孩子元素的下标为________。 


25.　  在一个具有n个顶点的无向完全图中，包含有________条边，在一个具有n个顶点的有向完全图中，包含有________条边。 


26.　  对于一个具有n个顶点和e条边的有向图和无向图，若采用边集数组表示，则存于数组中的边数分别为________和________条。 


27.　  以二分查找方法从长度为12的有序表中查找一个元素时，平均查找长度为________。 


28.　  假定一个线性表为(12,23,74,55,63,40,82,36)，若按Key % 3条件进行划分，使得同一余数的元素成为一个子表，则得到的三个子表分别为_____________、_____________和_____________。 


29.　  在线性表的散列存储中，装填因子a又称为装填系数，若用m表示散列表的长度，n表示待散列存储的元素的个数，则a等于________。 


30.　  在一棵m阶B_树上，每个非树根结点的关键字数目最少为________个，最多为________个，其子树数目最少为________，最多为________。 


31.　  表示图的三种常用的存储结构为__________、_______和________。 


32.　  对于一个具有n个顶点和e条边的有向图和无向图，在其对应的邻接表中，所含边结点分别有_______个和________个。 


33.　  对用邻接矩阵表示的有向图进行任一种遍历时，其时间复杂度为_________。对用邻接表表示的有向图进行任一种遍历时，其时间复杂度为________。 


34.　  对于线性表（70，34，55，23，65，41，20，100）进行散列存储时，若选用H（K）=K %9作为散列函数，则散列地址为1的元素有________个，散列地址为7的有_______个。 


35.　  
在索引表中，若一个索引项对应主表的一个记录，则此索引为__________索引 ，若对应主表的若干条记录，则称此索引为________索引。 


36.　  向一棵B_树插入元素的过程中，若最终引起树根结点的分裂，则新树比原树
的高度___________。 


37.　  在堆排序的过程中，对任一分支结点进行筛运算的时间复杂度为________，整个堆排序过程的时间复杂度为________。 


38.　  快速排序在平均情况下的时间复杂度为________，在最坏情况下的时间复杂度为________。 


39.　  在归并排序中，进行每趟归并的时间复杂度为______，整个排序过程的时间复杂度为____________，空间复杂度为___________。 


40.　  在快速排序、堆排序、归并排序中，_________排序是稳定的。 


　  三、运算题 


1.　  在如下数组A中链接存储了一个线性表，表头指针为A [0].next，试写出该线性表。 


　　　　　　　　　 a　　0　　 1　  2　　 3　  4　　 5　  6　　 7 

data

60
50
78
90
34

40

next
4
3
0
2
5
7

1




2.　  假定一棵二叉树广义表表示为a(b(c),d(e,f))，分别写出对它进行先序、中序、后序、按层遍历的结果。 


　　　　先序： 


　　　　中序： 


　　　　后序： 


　　　　按层： 


3.　　已知一棵二叉树的先序遍历的结果是ABECDFGHIJ, 中序遍历的结果是EBCDAFHIGJ, 试画出这棵二叉树。 


4.　　铁路进行列车调度时, 常把站台设计成栈式结构的站台，如下图1所示。试问： 


(1)  　　　　　　 设有编号为1,2,3,4的四辆列车, 顺序开入栈式结构的站台, 则可能的出栈序列有多少种? 


(2)  　　　　　　 若进站的四辆列车顺序如上所述, 那么是否能够得到4123这样的出栈序列？ 如果不能, 说明为什么不能。如果能, 说明如何得到该序列的（即写出“进栈”或“出栈”的序列）。 


(3)  　　　　　　 若进站的四辆列车顺序如上所述, 那么是否能够得到3421这样的出栈序列？ 如果不能, 说明为什么不能。如果能, 说明如何得到该序列的（即写出“进栈”或“出栈”的序列）。 



图1 


5.　　写出下列中缀表达式的后缀形式： 


　　　 (1) A * B * C 


　　　 (2) A + B - C + D 


　　　 (3) A* B + C 


　　　 (4) (A + B) * D + E / (F + A * D) + C 


6.　  画出下列广义表的带有附加表头结点的链接存储结构图，并给出它们的长度和深度。 


　　　 (1) D=（（a,b）,（c,d）） 


　　　 (2) A=（（a,（b,c）,（（d）,e））） 


7.　  将一组元素37,56,23,65,22,10,29依次插入一棵空二叉搜索树中，请画出该二叉搜索树。 


8.　　设有序
顺序表中的元素依次为017, 094, 154, 170, 275,503, 509, 512, 553, 612, 677, 765, 897, 908。试画出对其进行折半搜索时的判定树, 并计算搜索成功的平均搜索长度和搜索不成功的平均搜索长度。 


9.　　已知一个图的顶点集V和边集E分别为： 


　　　  V
={0,1,2,3,4,5,6,7}; 


　　　  E={(0,1)8,(0,2)5,(0,3)2,(1,5)6,(2,3)25,(2,4)13,(3,5)9,(3,6)10, 


　　　　　 (4,6)4,(5,7)20}; 


（1）按照普里姆算法从顶点0出发得到最小生成树，试写出在最小生成树中依次得到的各条边。 


（2）用克鲁斯卡尔算法得到最小生成树，试写出在最小生成树中依次得到的各条边。 


10.已知一个图的顶点集V和边集E分别为： 


　　　  V={1,2,3,4,5,6,7，8}; 


　　　  E={(1,2),(1,3),(2,4),(2,5),(3,6),(3,7),(4,8),(5,8), 


　　　　　 (6,8),(7,8)}; 


若存储它采用邻接表，并且每个顶点邻接表中的边结点都是按照终点序号从小到大的次序链接的，则： 


（1）给出从1号顶点出发按主教材中介绍的按深度优先搜索遍历的顶点序列 


（2）给出从1号顶点出发按主教材中介绍的按广度优先搜索遍历的顶点序列 


　　  （提示：先画出对应的图形，然后再运算）。 


11.已知一个图的顶点集V和边集E分别为： 


　　　  V={0,1,2,3,4,5,6,7}; 


　　　  E={(0,2),(1,3),(1,4),(2,4),(2,5),(3,6),(3,7),(4,7),(4,8), 


　　　　　 (5,7),(6,7),(7,8)}; 


若存储它采用邻接表，并且每个顶点邻接表中的边结点都是按照终点序号从小到大的次序链接的，按主教材中介绍的拓朴排序算法进行排序，试给出得到的拓朴排序的序列。（提示：先画出对应的图形，然后再运算）。 


12.散列表的地址区间为0-16，散列函数为H（K）=K % 17，采用线性探查法处理冲突，并已将关键字序列26、25、72、38、8、18、59依次存储到了散列表中： 


（1）元素59存放在散列表中的地址是多少？ 


（2）搜索元素59需要比较的次数是多少？ 


13.已知待散列的线性表为（36，15，40，63，22），散列用的一维地址空间为[0..6]，假定选用的散列函数是H（K）=K % 7，若发生冲突采用线性探查法处理，试： 


（1）计算出每一个元素的散列地址并在下图中填写出散列表； 


（2）求出在查找每一个元素概率相等情况下的平均查找长度。 

0
1
2
3
4
5
6












14.假定一组记录的排序码为(46,79,56,38,40,80,25,34)，试写出对其进行快速排序的第一次划分的结果。 


　  四、阅读算法，回答问题 


1.　　void AE(Stack&amp; S) 


　　　 { 


　　　　　 InitStack(S); 


　　　　　 Push(S,30); 


　　　　　 Push(S,40); 



　　　 　　Push(S,50); 


　　　　　 int x=Pop(S)+2*Pop(S); 


　　　　　 Push(S,x); 


　　　　　 int i,a[4]={5,8,12,15}; 


　　　　　 for(i=0;i&lt;4;i++) Push(S,a[i]); 


　　　　　 while(!StackEmpty(S)) cout&lt;&lt;Pop(S)&lt;&lt;&#39; &#39;; 


　　　 } 


　　该算法被调用后得到的输出结果为： 


2.　　  void AJ(adjlist GL, int i, int n) 


　　 　{ 


　　　　　 Queue Q; 


　　　　　 InitQueue(Q); 


　　　　　 cout&lt;&lt;i&lt;&lt;&#39; &#39;; 


　　　　　 visited[i]=true; 


　　　　　 QInsert(Q,i); 


　  　　　 while(!QueueEmpty(Q)) { 


　　　 　　　　int k=QDelete(Q);  


　　　  　　　 edgenode* p=GL[k];  


　　　  　　　 while(p!=NULL) 


　　　  　　　 { 


　　　　　 　　　　int j=p-&gt;adjvex;  


　　　　　  　　　 if(!visited[j]) {  


　　　　　  　 　　　　cout&lt;&lt;j&lt;&lt;&#39; &#39;; 


　　　　　　　  　　　 visited[j]=true; 


　　　　　　　  　　　 QInsert(Q,j); 


　　　　　  　　　 } 


　　　　　  　　　 p=p-&gt;next;  


　　　  　　　 } 


　　　　　 } 


　　　 } 


该算法的功能为： 


3.　　指出下列算法的功能，并求出时间复杂度： 


（1）int sum1(int n) 


　　　　　 { 


　　　　　  int p=1,s=0; 


　　　　　  for (int i=1;i&lt;=n;i++){ 


　　　　　　　　 p*=i;s+=p; 


　　　　　　　　 } 


　　　　　  return s; 


　　　　　  } 


（2）int sum2(int n) 


　　　　　 { 


　　　　　  int s=0; 


　　　　　for (int i=1;i&lt;=n;i++){ 


　　　　　　　　 int p=1; 


　　　　　　　　 for (int j=1;j&lt;=i;j++) 


　　　　　　　　  p*=j; 


　　　　　　　　  s+=p; 


　　　　　　　　 } 


　　　　　  return s; 


　　　　　  } 


4.　  在下面的每个程序段中，假定线性表La的类型为List，元素类型ElemType为int，并假定每个程序段是连续执行的。试写出每个程序段执行后所得到的线性表La。 


（1）InitList(La); 


　　　　Int a[]={48,26,57,34,62,79}; 


For (i=0;i&lt;6;i++) 


Insert(La,a[i]); 


　　　　TraverseList(La); 


（2）Insert(La,56); 


DeleteFront(La); 


InsertRear(La, DeleteFront(La)); 


　　　　TraverseList(La); 


（3）For (i=1;i&lt;=3;i++){ 


　  　　　　 Int x=GetElem(La,i); 


　　　　　　 If (x%2==0) Delete(La,x); 


　　　　} 


　　　　TraverseList(La); 


（4）ClearList(La); 


　　　　For (i=0;i&lt;6;i++) 


　　　　　　 InsertRear(La,a[i]); 


　　　　Delete(La,a[5]); 


　　　　Sort(La); 


　　　  
Insert(La,a[5]/2); 


　　　　TraverseList(La); 


　  五、算法填空，在画有横线的地方填写合适的内容。 


1.　   向单链表的末尾添加一个元素的算法。 


Void InsertRear(LNode*&amp; HL,const ElemType&amp; item) 


{ 


LNode* newptr; 


newptr=new LNode; 


If (______________________) 


{ 


cerr&lt;&lt;&quot;Memory allocation failare!&quot;&lt;&lt;endl; 


exit(1); 


} 


newptr-&gt;data=item; 


_________________=NULL; 


if (HL
==NULL) 


　HL=newptr; 


else{ 


LNode* P=HL; 


While (P-&gt;next!=NULL) 


　 ____________________; 


p-&gt;next=newptr; 


} 


　　　　} 


2.　  向以BST为树根指针的二叉搜索树上插入值为item的结点的递归算法。 


　　　　void Insert(BTreeNode*&amp; BST, const ElemType&amp; item) 


　　　　{ 


　　　　　  if(BST==NULL) 


　　　　　  {　 BTreeNode* p=new BTreeNode; 


　　　  　　　　p-&gt;data=item; 


　　　  　　　  _______________________; 


　　　  　　　　BST=p; 


　　　　　  } 


　　　　　  else if(item&lt;BST-&gt;data) ___________________; 


　　　　　  else ________________________; 


　　　　} 


3.　　二分查找的递归算法。 


　　　　 Int Binsch(ElemType A[],int low,int high,KeyType K) 


　　　　{ 


　　　　 if (low&lt;=high){ 


　　　　　  int mid=(low+high)/2; 


　　　　　  if (_____________________) 


　　　　　　　 return mid;　　　　　　　　　　 //查找成功，返回元素的下标 


　　　　　  else if (K&lt;A[mid]) 


　　　　　　　 return Binsch(A,low,mid-1,K);　　　　　　 //在左子表上继续查找 


　　　　　  else return_____________________________；　　 //在右子表上继续查找 


　　　　　 } 


　　　　 else ________________；　　　　　　  //查找失败，返回-1 


　　　　} 


　  六、编写算法 


1.　　　 编写向类型为List的线性表L中第i个元素位置插入一个元素的算法，假定不需要对i的值进行有效性检查，同时不需要检查存储空间是否用完。 


　　　　void Insert(List&amp; L, int i, ElemType x) 





2.　　　 设有一个线性表 (e0, e1, …, en-2, en-1) 存放在一个一维数组A[arraySize]中的前n个数组元素位置( arraySize&gt;=n)。请编写一个函数将这个线性表原地逆置，即将数组的前 n个原址内容置换为 (en-1, en-2, …, e1, e0)。 


　　　void inverse ( ElemType A[ ], int n ) 





3.　　　 试编写一个算法，在带表头结点的单链表中寻找第i个结点。若找到，则函数返回第 i个结点的地址；若找不到，则函数返回NULL。 


　　　LNode*　GetANode (LNode* &amp; HL
， int i ) 





参考答案 


一、　　　　　　 单选题 


1.B  2.B　3.D　4.C　5.A  6.B　7.D　8.B　9.A　10.A　11.C  12.D　13.D　14.A　15.C　16.B　17.A  18.C　19.B　20.A　21.C　22.A 





二、　　　　　　 填空题 


1.　　　 集合结构  线性结构　树结构　图结构 


2.　　　 顺序　链表  索引　散列  


3.　　　 O(n) 


4.　　　 O(1)　O(n) 


5.　　　 O(n)　O(1) 


6.　　　 HL-&gt;next==NULL　 HL-&gt;next==HL 


7.　　　 单　 表 


8.　　　 指针（或next）  栈顶指针（或H
S） 


9.　　　 返回地址 


10.　　36*6(或 216)　  12*6（或72）　310 


11.　　p-&gt;next　a[p].next 


12.　　（矩阵元素的）行号　 （矩阵元素的）列号 


13.　　先进后出表（或后进先出表）  先进先出表 


14.　　3　4 + 2　* 8　5　- / 


15.　　8 


16.　　2i　 2i+1　  ?i/2?（或i/2） 


17.　　16　 31  


18.　　10　 4　 3 


19.　　k-1  


20.　　 度 


21.　　哈夫曼树木 带权路径长度 


22.　　有（或升）序序列 


23.　　向上　 根  


24.　　2i+1　 2i+2 


25.　　n(n-1)/2　 n(n-1) 


26.　　e　e 


27.　　37/12 


28.　　(12,63,36)　 (55,40,82)  (23,74) 


29.　　n/m　 


30.　　 ｅm/2ｕ-1　　 m-1　　 ｅm/2ｕ　　 m 


31.　　邻接矩阵　 邻接表　 边集数组 


32.　　e　 2e　 


33.　　O(n2)　O(e)  


34.　　2　 2 


35.　　稠密　 稀疏 


36.　　增加1 


37.　　O(log2n)　 O(nlog2n) 


38.　　O(nlog2n)　 O(n2) 


39.　　O(n)　 O(nlog2n)　O(n) 


40.　　归并 





三、运算题 


1.　　　 【解答】(90,34,40,60,78,50) 


2.　　　 【解答】 


　　　　先序： a,b,c,d,e,f　　　　 


　　　　中序： c,b,a,e,d,f　　　  


　　　　后序： c,b,e,f,d,a　　　  


　　　　按层： a,b,d,c,e,f　　　  


3.　　　 【解答】 


当前序序列为ABECDFGHIJ，中序序列为EBCDAFHIGJ时，逐步形成二叉树的过程如下图2所示：  


EBCD 




FHIGJ 




A 




A 




B 




E 




F 




CD 




HIGJ 




A 




B 




E 




F 




C 




D 




G 




J 




HI 




A 




B 




E 




F 




C 




D 




G 




J 




h 




I 





























图2 


4.　　　 【解答】 


（1）不同的出栈序列有14种。 


（2）　　　 不能得到4123这样的出栈序列。因为若在4之后再将1, 2，3出栈，则必有1, 2，3在4前入栈，即1先进栈，2后进栈，3再进栈，此时3压在2上，2压在1上。最后4进栈。4
首先出栈，由于1压在最下面，由栈的特性知此时1不可能先于2和3出栈，所以4123种出栈序列不可能出现。 


（3）能得到3421这样的出栈序列。即1入栈，2 入栈，3入栈，然后3出栈，再4入栈，接着4出栈，2出栈，1 出栈。 


5.　　　 【解答】 


　　　 (1) A B * C * 


　　　 (2) A  B + C - D + 


　　　 (3) A  B * C + 


　　　 (4) A B + D * E F A D * + / + C + 


6.　　　 【解答】(1) D的长度为2，深度为2，其链接存储结构见下图3(a) 


D 





　　　　　　　  (2) A的长度为
1，深度为4，其链接存储结构见下图3(b)




1　　　ù 




1 




1　　 ù 




0　a 




0 b　ù 




0　c 




0　d　ù 





图3(a)







A 












1　　ù 




1　　ù 




0　a 




1 




1　　 ù 




0　b 




0　c　ù 




1  




0　e　ù 




0　d　ù 





图3(b)




7.　　　 37 




23 




56 




22 




29 




65 





构造的二叉搜索树如下图4所示：




10 





图4




8.　　　 509 




【解答】




　　　 154 




017 




275 




094 




170 




503 




677 




553 




897 




512 




612 




765 




908 






























图5 








9.　　　 （1）普里姆：(0,3)2, (0,2)5, (0,1)8, (1,5)6, (3,6)10, (6,4)4, (5,7)20 


　 　　 （2）克鲁斯卡尔：(0,3)2,（4,6）4,(0,2)5,(1,5)6,(0,1)8,(3,6)10,(5,7)20 


10.　　（1）DFS：1，2，4，8，5，6，3，7 


　　　  （2）BFS：1，2，3，4，5，6，7，8 


11.　  拓扑序列：1,3,6,0,2,5,4,7,8　 


12.　　（1）11　　  （2）4 


13.　　（1） H（36）=36 % 7=1 


　　　　　　  H（15）=15 % 7=1 冲突　  H1（15）=（15+1） % 7=2 


　　　　　　  H（40）=40 % 7=5 


　　　　　　  H（63）=63 %7=0 


　　　 H（22）=22 % 7=1  冲突　H1（22）=（22+1）% 7=2　冲突  H2（22）=（22+2）%7=3 

0
1
2
3
4
5
6

63
36
15
22

40





　　　  （2）平均查找长度=(1+2+1+1+3)/5=1.6 


14.　　 [40 34 25 38] 46 [80 56 79]　  





　　  四、阅读算法，回答问题 


1.　　 输出结果为：15 12 8 5 130 30 


2.　　　 功能为：从初始点vi出发广度优先搜索由邻接表GL所表示的图。 


3.　　 （1）功能为：s=1!+2!+……n!　　时间复杂度O(n) 


（2）功能同（1），时间复杂度O(n2) 


4.　　 (1)　(26,34,48,57,62,79) 


(2)　　　 (48,56,57,62,79,34) 


(3)　　　 (57,62,79,34) 


(4)　　　 (26,34,39,48,57,62) 


　  五、算法
填空，在画有横线的地方填写合适的内容。 


1.　  nwptr==NULL　　　　  newptr-&gt;　　　　  p=p-&gt;next; 


2.　  p-&gt;left=p-&gt;right=NULL　　　 Insert(BST-&gt;left, item)  


　　　 Insert(BST-&gt;right, item) 


3．K==A[mid].key　　　　 Binsch(A,mid+1,hight,K)　　　　 return -1 


　六、编写算法 


1.　　void Insert1(List&amp; L, int i, ElemType x) 


　　　 { 


　  　　　 for(int j=L.size-1; j&gt;=i-1; j--) 


　　　 　　　　L.list[j+1]=L.list[j]; 


　　　　　 L.list[i-1]=x;　　　　　  //第i个元素的下标
为i-1 


　  　　　 L.size++; 


　　　 } 


2.　　void inverse ( ElemType A[ ], int n ) 


　　　 { 


　　　　ElemType  tmp; 


　　　　for ( int i = 0; i &lt;= ( n-1 ) / 2; i++ ) { 


　　　　　  tmp = A[i];　A[i] = A[n-i-1];　A[n-i-1] = tmp; 


　　　　　  } 


　 　　 } 


3.　　　LNode*　 GetANode (LNode* &amp; HL， int i ) 


{　　//取得带有头对点的单链表中第i个结点地址（ i从1开始计数）。若 i &lt;=0或　　　　　 i&gt;表长时，返回的指针值为NULL。 


　　　　if ( i &lt;=0 ) return NULL; 


　　　　LNode * p =HL-&gt;next;　int k = 1; 


　　　　while ( p != NULL &amp;&amp; k &lt; i ) { p = p-&gt;next;　k++; } 


　　　　return p; 


　　　　} 











